<html>
<head>
<title>../map.h</title>
<link rel="stylesheet" type="text/css" href="cppdoc.css" />
</head>
<body>
<pre class=code>
<scan class=comment>/*
 * File: map.h
 * -----------
 * This interface defines a map abstraction that associates string-valued
 * keys with values.  In contrast to the HashMap type defined in the
 * hashmap.h interface, the implementation of the Map type uses a balanced
 * binary tree, which offers logarithmic performance and sorted iteration.
 *
 * In most applications, the restriction of keys to strings is easy to
 * circumvent.  The simplest strategy is to convert key values to strings
 * before inserting them into the map.  A more general strategy is to use
 * the bst.h interface instead.
 */
</scan>
#ifndef _map_h
#define _map_h

#include "cslib.h"
#include "generic.h"
#include "iterator.h"

<a name="Type:Map"><scan class=comment>/*
 * Type: Map
 * ---------
 * This type is the ADT used to represent the map.
 */
</scan>
typedef struct MapCDT *Map;

<scan class=comment>/* Exported entries */</scan>

<a name="Function:newMap"><scan class=comment>/*
 * Function: newMap
 * Usage: map = newMap();
 * ----------------------
 * Allocates a new map with no entries.
 */
</scan>
Map newMap();

<a name="Function:freeMap"><scan class=comment>/*
 * Function: freeMap
 * Usage: freeMap(map);
 * --------------------
 * Frees the storage associated with the map.
 */
</scan>
void freeMap(Map map);

<a name="Function:size"><scan class=comment>/*
 * Function: size
 * Usage: n = size(map);
 * ---------------------
 * Returns the number of elements in the map.
 */
</scan>
int sizeMap(Map map);

<a name="Function:isEmpty"><scan class=comment>/*
 * Function: isEmpty
 * Usage: if (isEmpty(map)) . . .
 * ------------------------------
 * Returns true if the map has no entries.
 */
</scan>
bool isEmptyMap(Map map);

<a name="Function:clear"><scan class=comment>/*
 * Function: clear
 * Usage: clear(map);
 * ------------------
 * Removes all entries from the map.
 */
</scan>
void clearMap(Map map);

<a name="Function:clone"><scan class=comment>/*
 * Function: clone
 * Usage: newmap = clone(map);
 * ---------------------------
 * Creates a copy of the map.  The clone function copies only the first
 * level of the structure and does not copy the individual elements.
 */
</scan>
Map cloneMap(Map map);

<a name="Function:put"><scan class=comment>/*
 * Function: put
 * Usage: put(map, key, value);
 * ----------------------------
 * Associates key with value in the map.  Each call to put supersedes any
 * previous definition for key.
 */
</scan>
void putMap(Map map, string key, void *value);

<a name="Function:get"><scan class=comment>/*
 * Function: get
 * Usage: void *value = get(map, key);
 * -----------------------------------
 * Returns the value associated with key in the map, or NULL, if no such
 * value exists.
 */
</scan>
void *getMap(Map map, string key);

<a name="Function:containsKey"><scan class=comment>/*
 * Function: containsKey
 * Usage: if (containsKey(map, key)) . . .
 * ---------------------------------------
 * Checks to see if the map contains the specified key.
 */
</scan>
bool containsKeyMap(Map map, string key);

<a name="Function:remove"><scan class=comment>/*
 * Function: remove
 * Usage: remove(map, key);
 * ------------------------
 * Removes the key and its value from the map.
 */
</scan>
void removeMap(Map map, string key);

<a name="Function:map"><scan class=comment>/*
 * Function: map
 * Usage: map(map, fn, data);
 * --------------------------
 * Iterates through the map and calls the function fn on each entry.  The
 * callback function takes the following arguments:
 *
 *
 *  The key
 *  The associated value
 *  The data pointer
 *
 *
 * The data pointer allows the client to pass state information to the
 * function fn, if necessary.  If no such information is required, this
 * argument should be NULL.
 */
</scan>
void mapMap(Map map, proc fn, void *data);

#endif
</pre>
</body>
</html>
